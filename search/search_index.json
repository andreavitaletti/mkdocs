{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GOAL","text":"<p>This short course on the Internet of Things is designed to give a first understanding of the main issues in developing IoT solutions. We do believe the most efficient way to learn this subject is experimenting, this is way the course encourage attendants to hands-on. No specific background is needed, even if a basic knowledge of electronics and computer science might help. </p>"},{"location":"#session-1-4-hours","title":"SESSION 1 (4 hours)","text":"<p>GOAL: Quick intro to the Internet of Things.</p> <ul> <li>Introduction to the IoT</li> <li>IoT and Big Data: we can quantitatively measure phenomena that up to yesterday we were only able to guess</li> <li>A network of Resource Constrained Devices: if computational power, memory, energy, bandwidth and costs are not constrained, it is likely Internet, not Internet of Things.</li> </ul>"},{"location":"#session-2-4-hours","title":"SESSION 2 (4 hours)","text":"<p>GOAL: Small experiment (a single sensor). Prove you can integrate sensors suitable for you monitoring purpose.  Focus on effectiveness, namely doing the right things, i.e., the Maker approach.</p> <ul> <li>The reference hardware: ESP32</li> <li>Hands on with the Arduino Ide and Wokwi</li> <li>A simple integration of sensor/actuator</li> <li>Communicating over WiFi</li> </ul>"},{"location":"#session-3-4-hours","title":"SESSION 3 (4 hours)","text":"<p>GOAL: Small experiment (a single sensor). Focus on efficiency, namely doing the things right, i.e., the Engineers approach. Use metrics to measure to what extent your solution satisfies the user requirements.</p> <ul> <li>The need of an Operating System </li> <li>Hands on FREERTOS</li> <li>A simple integration of sensor/actuator</li> <li>Communicating over WiFi</li> </ul>"},{"location":"#session-4-4-hours","title":"SESSION 4 (4 hours)","text":"<p>GOAL: Scale-up in a realistic environment.</p> <ul> <li>The Very Large Scale IoT Testbed IoT-LAB </li> <li>FreeRTOS on IoT-lab</li> <li>A simple Project</li> </ul>"},{"location":"#tools-and-materials","title":"Tools and Materials","text":"<p>I like vscode with the Remote-SSH extension to interact with the virtual machine for FreeRTOS development. However, during the class there might be many issues due to different version of the OS and vscode. To further simplify the process I use micro a modern and intuitive terminal-based text editor. Give it a try, it is very convenient. I also suggest to install the file manager plugin. The only annoying issue I'm currently facing with micro is that copy/past does not work smoothly over SSH, you have to use ctr + shift + V</p>"},{"location":"#material","title":"Material","text":"<p>The list of material for each group: 1 ESP32-DevKit, a breadboard, some wires and resistors, one led, one button, one potentiometer and one 3 Axis Accelerometer Gyroscope</p> <ul> <li> <p>ESP32-DevKit e.g. Available on Amazon</p> </li> <li> <p>A breadboard e.g. Available on Amazon</p> </li> <li> <p>Wires e.g. Available on Amazon</p> </li> <li> <p>Resistors e.g. Available on Amazon</p> </li> <li> <p>Minimal actuator, namely a led and resistors - resistor 330 Ohm e.g. Available on Amazon</p> </li> <li> <p>Minimal analog sensor, namely a potentiometer 10 KOhm e.g. Available on Amazon</p> </li> <li> <p>Minimal digital sensor, namely a button - resistor 1 KOhm e.g. Available on Amazon</p> </li> <li> <p>A more interesting digital vibration sensor SW-420 e.g. Available on Amazon</p> </li> <li> <p>3 Axis Accelerometer Gyroscope Sensor Module GY-521 MPU6050 Modulee.g. Available on Amazon</p> </li> </ul>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>Code and Slides</li> <li>The Espressif software development environment</li> <li>Arduino Ide</li> <li>Wokwi</li> <li>FREERTOS</li> <li>IoT-LAB </li> <li>Thingsboard</li> <li>A short paper on this course</li> </ul>"},{"location":"#editions","title":"Editions","text":"<p>First edition of the course 19th (Session 1 and 2) and 21st (Session 3 and 4) of July 2023 in the University of Stellenbosch (South Africa) during an Erasmus+ staff mobility for teaching visit. About 40 participants selected among more the 100 candidates. Keep in touch on the discord server. A new version soon.</p> <p></p>"},{"location":"iot-lab/","title":"IOT-LAB","text":""},{"location":"iot-lab/#run-a-lorawan-experiment","title":"Run a Lorawan experiment","text":"<pre><code>ssh vitalett@saclay.iot-lab.info \n</code></pre> <pre><code>git clone https://github.com/FreeRTOS/FreeRTOS-LTS.git\ncd FreeRTOS-LTS/FreeRTOS\ngit clone https://github.com/Lora-net/LoRaMac-node.git\ncd cd LoRaMac-node/\n</code></pre> <pre><code>nano  src/boards/B-L072Z-LRWAN1/board.c\n\n// change the baudrate to 115200 to be compatible with iot-lab serial \n\nUartConfig( &amp;Uart2, RX_TX, 115200, UART_8_BIT, UART_1_STOP_BIT, NO_PARITY, NO_FLOW_CTRL );\n</code></pre> <pre><code>nano src/peripherals/soft-se/se-identity.h\n\n// update credentials to connect to TTN\n#define STATIC_DEVICE_EUI       1\n#define LORAWAN_DEVICE_EUI      LORAWAN_DEVICE_EUI_ON_TTN\n#define LORAWAN_JOIN_EUI        LORAWAN_APP_EUI_ON_TTN\n#define STATIC_DEVICE_ADDRESS   1\n#define LORAWAN_DEVICE_ADDRESS  DEVICE_ADDRESS_TTN\n\n.KeyID = NWK_KEY,           \n.KeyValue = LORAWAN_APP_KEY_ON_TTN\n</code></pre> <pre><code>mkdir build\ncd build\n\ncmake -DCMAKE_BUILD_TYPE=Release         -DTOOLCHAIN_PREFIX=\"/opt/gcc-arm-none-eabi-4_9-2015q1/\"      -DCMAKE_TOOLCHAIN_FILE=\"../cmake/toolchain-arm-none-eabi.cmake\"         -DAPPLICATION=\"LoRaMac\"         -DSUB_PROJECT=\"periodic-uplink-lpp\"         -DCLASSB_ENABLED=\"ON\"         -DACTIVE_REGION=\"LORAMAC_REGION_EU868\"         -DREGION_EU868=\"ON\"         -DREGION_US915=\"OFF\"         -DREGION_CN779=\"OFF\"         -DREGION_EU433=\"OFF\"         -DREGION_AU915=\"OFF\"         -DREGION_AS923=\"OFF\"         -DREGION_CN470=\"OFF\"         -DREGION_KR920=\"OFF\"         -DREGION_IN865=\"OFF\"         -DREGION_RU864=\"OFF\"         -DBOARD=\"B-L072Z-LRWAN1\"       -DSECURE_ELEMENT=\"SOFT_SE\"         -DSECURE_ELEMENT_PRE_PROVISIONED=\"OFF\"         -DUSE_RADIO_DEBUG=\"ON\" ..\n\nmake\n</code></pre> <pre><code>cd src/apps/LoRaMac/\n\niotlab-experiment submit -n rtos_ttn -d 60 -l 1,archi=st-lrwan1:sx1276+site=saclay\n{\n    \"id\": 394774\n}\n\niotlab-experiment get -i 394774 -s\n\niotlab-experiment get -i 394774 -r\n\niotlab-node --flash LoRaMac-periodic-uplink-lpp -l saclay,st-lrwan1,10\n\nnc st-lrwan1-10 20000\n</code></pre>"},{"location":"session1/","title":"SESSION 1","text":"<p>GOAL: Quick intro to the Internet of Things.</p>"},{"location":"session1/#takeaway-one","title":"Takeaway ONE","text":"<ul> <li>IoT is fuel for Big Data Analytics</li> <li> <p>\"When you can measure ... you know something\". Lord Kelvin docet.</p> </li> <li>IoT provide quantitative evidences on  phenomena that we used to investigate only qualitatively</li> </ul>"},{"location":"session1/#takeaway-two","title":"Takeaway TWO","text":"<ul> <li>IoT is a network of resource constrained devices</li> <li>Constraints require design choices</li> <li>Beyond the maker approach, namely when effectiveness meets efficiency</li> </ul>"},{"location":"session2/","title":"SESSION 2","text":"<p>GOAL: Small experiment (a single sensor). Prove you can integrate sensors suitable for you monitoring purpose.  Focus on effectiveness, namely doing the right things, i.e., the Maker approach.</p>"},{"location":"session2/#the-reference-hardware-esp32-devkit","title":"The reference hardware: ESP32-DevKit","text":""},{"location":"session2/#lets-start-by-simulating-it","title":"Let's start by simulating it","text":"<p>Wokwi is an online Electronics simulator. You can use it to simulate Arduino, ESP32, STM32, and many other popular boards, parts and sensors.</p> <ul> <li>The simplest actuator, namely a led</li> <li>The Simplest sensor, namely a button</li> <li>A bit more interesting sensor, namely a potentiometer</li> <li>A simple example with SR04 Ultrasonic Sensor. The width is measured by the function pulseIn().</li> </ul> <p></p> <ul> <li>It's time to be connected by MQTT. The mosto convenient way is to use your mobile an Access Point and configure SSID and password consequently.</li> </ul> <pre><code>mosquitto_pub -h test.mosquitto.org -t \"topicName/led\" -m \"on\"\nmosquitto_pub -h test.mosquitto.org -t \"topicName/led\" -m \"off\"\n</code></pre> <pre><code>mosquitto_sub -h test.mosquitto.org -t \"wokwi/temperature\"\n</code></pre> <p>Another possible broker is mqtt://mqtt.eclipseprojects.io</p> <ul> <li>Build a simple backend with thingsboard https://demo.thingsboard.io/login</li> </ul> <p> </p> <p>https://thingsboard.io/docs/getting-started-guides/helloworld/?connectdevice=mqtt-linux</p> <pre><code>mosquitto_pub -d -q 1 -h \"$THINGSBOARD_HOST_NAME\" -p \"1883\" -t \"v1/devices/me/telemetry\" -u \"$ACCESS_TOKEN\" -m {\"temperature\":25}\n</code></pre> <p>NOTE: for the sake of convenience, we will use WiFi connectivity, however it should be now clear WiFi is usually not appropriate for IoT applications due to the excessive energy demand. </p>"},{"location":"session2/#it-is-time-to-work-with-a-real-device","title":"It is time to Work with a real device","text":"<ul> <li>Download the code from Wokwi. It is also available on https://github.com/andreavitaletti/IoT_short_course/tree/main/src/simulator</li> <li>The easiest way it to use the Arduino IDE </li> <li>Since we are using the ESP32, you have to follow these intructions</li> <li>Select the DOIT ESP32 DEVKIT V1 as in the picture below and upload the code</li> </ul> <ul> <li>The only novelty is the vibration sensor SW-420 ... but please have a look to the SR04 Ultrasonic Sensor and adapt it to make it working with the SW-420. </li> </ul> <p>This sketch could help</p> <pre><code>// Watch video here: https://www.youtube.com/watch?v=235BLk7vk00\n\n/* Vibration sensor connected to Arduino pins as follows:\n\n ESP32 Arduino Vibration Sensor\n https://wolles-elektronikkiste.de/esp32-mit-arduino-code-programmieren\n   D18 --&gt; GPIO18 --&gt; G18        DOut\n   GND                           GND\n   +5V --&gt; 3.3V                  VCC      \n*/\n\nint EP = 18;\n\nvoid setup(){\n  pinMode(EP, INPUT); //set EP input for measurment\n  Serial.begin(9600); //init serial 9600\n}\nvoid loop(){\n  long measurement =TP_init();\n  delay(50);\n  Serial.println(measurement);\n}\n\nlong TP_init(){\n  delay(10);\n  long measurement=pulseIn (EP, HIGH);  //wait for the pin to get HIGH and returns measurement\n  return measurement;\n}\n\n</code></pre> <p>Through pulseIn() we can measure the duration of a vibration event exceeding the threshold, not the frequency of the vibrations themselves. Indeed, the Arduino pulseIn() function waits for a change in the binary input (Low to High in this instance) and returns the duration that the detected pulse was active (time for it to go back High to Low after going High).</p> <p>QUESTION: Can we use this function to help in anomaly detection? see here for inspiration!</p> <p></p>"},{"location":"session3/","title":"SESSION 3","text":"<p>GOAL: Small experiment (a single sensor). Focus on efficiency, namely doing the things right, i.e., the Engineers approach. Use metrics to measure to what extent your solution satisfies the user requirements.</p> <p>Well, to develop an IoT application as an engineer, we do need a Real-Time Operating System (RTOS). What is An RTOS?. </p> <p>Embedded systems often have real time requirements. A real time requirements is one that specifies that the embedded system must respond to a certain event within a strictly defined time (the deadline). A guarantee to meet real time requirements can only be made if the behaviour of the operating system's scheduler can be predicted (and is therefore deterministic). FreeRTOS, achieve determinism by allowing the user to assign a priority to each thread of execution. The scheduler then uses the priority to know which thread of execution to run next. In FreeRTOS, a thread of execution is called a task.</p> <p>Here there is a nice explanation of the main features provided by FreeRTOS, namely </p> <ul> <li>Multitasking</li> <li>Scheduling</li> <li>Context Switching</li> <li>Real Time Applications</li> <li>Real Time Scheduling</li> </ul> <p>FreeRTOS FAQ - What is This All About?</p> <p>Finally a nice example of the design of a real-time application </p> <p>A book on FreeRTOS.</p>"},{"location":"session3/#development-environment","title":"Development environment","text":"<p>To develop our solution on our ESP32, we need to setup the environment as described here. A very convenient way is to use docker as explained here. </p> <p>To further simplify the development process, a multi-platform Virtualbox image is available here. Next we will focus on this method. Credentials to work with the virtual machine are root/root and devel/devel and we will connect in ssh as explained below. </p> <p>The reference folder for the code and the examples is https://github.com/espressif/esp-idf.git which is already available on the virtual machine on </p> <ol> <li><code>ssh devel@localhost -p 2222</code> ... the password is devel</li> <li><code>get_idf</code> ... we set up the development environment</li> <li><code>cd ~/esp</code></li> <li><code>cp -r ./esp-idf/examples/get-started/hello_world/ ./workshop/</code> ... make a copy of a dir in the example in the workshop dir </li> <li><code>cd ./workshop/hello_world/</code></li> <li><code>idf.py build</code> ... i t takes some time</li> <li><code>idf.py flash</code> ... be sure the ESP32 is connected to \\dev\\ttyUSB0 and check it is visible in the virtual machine</li> <li><code>idf.py monitor</code> ... to exit from the monitor ctrl+T ctrl+X</li> </ol> <p>NOTE in some cases you can configure specific parameters running idf.py menuconfig</p> <p>In the virtual machine you have first to  <code>export LC_ALL=C</code></p>"},{"location":"session3/#clone-only-the-relevant-code","title":"Clone only the relevant code","text":"<pre><code># Create a directory, so Git doesn't get messy, and enter it\nmkdir code_from_git &amp;&amp; cd code_from_git\n\n# Start a Git repository\ngit init\n\n# Track repository, do not enter subdirectory\ngit remote add -f origin https://github.com/andreavitaletti/IoT_short_course\n\n# Enable the tree check feature\ngit config core.sparseCheckout true\n\n# Create a file in the path: .git/info/sparse-checkout\n# That is inside the hidden .git directory that was created\n# by running the command: git init\n# And inside it enter the name of the sub directory you only want to clone\necho 'src/freertos' &gt;&gt; .git/info/sparse-checkout\n\n## Download with pull, not clone\ngit pull origin main\n</code></pre>"},{"location":"session3/#a-quick-introduction-to-tasks","title":"A quick introduction to tasks","text":"<p>Based on ESP32 ESP-IDF FreeRTOS Tutorial: Learn to Create Tasks. The code is available on our github repo</p>"},{"location":"session3/#the-examples-of-session-2-on-freertos","title":"The examples of SESSION 2 on FreeRTOS","text":"<p>In this section we will implement the reference examples developed in day2 into FreeRTOS. The idea is to take inspiration from the examples available at https://github.com/espressif/esp-idf/tree/master/examples and modify them to get the same behavior of the ones developed in DAY2</p> <ul> <li>The simplest actuator, namely a led</li> <li>The Simplest sensor, namely a button</li> <li>A bit more interesting sensor, namely a potentiometer</li> <li>A simple example with SR04 Ultrasonic Sensor</li> <li>It's time to be connected by MQTT</li> <li>About the vibration sensor SW-420 ... have a look here</li> </ul> <p>Nice tutorials on the same topics are also available here</p>"},{"location":"session3/#data-streaming-in-industrial-iot","title":"Data Streaming in Industrial IoT","text":"<ul> <li>MQTT</li> <li>OPCUA</li> <li>Apache Kafka</li> </ul>"},{"location":"session4/","title":"SESSION 4","text":"<p>GOAL: Scale-up in a realistic environment.</p> <p>IoT-LAB provides a very large scale infrastructure suitable for testing small wireless sensor devices and heterogeneous communicating objects.</p> <p>Even if the ESP32 is not currently among the supported hardware, IoT-LAB supports FreeRTOS.</p> <ul> <li>Once you have setup a user connect to a lab by ssh, as an example</li> </ul> <pre><code>ssh vitalett@grenoble.iot-lab.info\n</code></pre> <ul> <li>Follow the instructions here to run FreeRTOS on IoT-LAB</li> <li>The reference code is available on https://github.com/iot-lab/openlab and in particular we are inetrested in the tutorial</li> <li>Once the code has been compiled, it can run into an experiment as explained here</li> <li>A quite unique feature, is the ability to perform consuption monitoring as explained here. To plot the graphs, download the oml files and use the following tools</li> </ul>"},{"location":"supplement1/","title":"Tensorflow Lite Micro on ESP32","text":"<p>Reference examples are available here. You have to download from github esp-nn and esp32-camera and place them into the relative folders under components.</p> <p>Then go to examples/hello_worlds and as usual idf.py build, idf.py flash and finally idf.py monitor.</p> <p>A nice explanation on how the model is generated can be found on the book TinyML by Pete Warden, Daniel Situnayake. The corresponding jupyter notebook is available here</p> <p>Some other useful resources are listed below:</p> <ul> <li>First steps with ESP32 and TensorFlow Lite for Microcontrollers</li> <li>Get started with microcontrollers</li> </ul>"},{"location":"supplement2/","title":"Kalman Filters","text":"<p>A very nice, rich an exhaustive source of documentation for Kalman filters is available here</p> <p>The main idea is that both our prior knowledge and the measurements of our sensors are to some extent inaccurate. To model such inaccuracy we use a Gaussian with mean $$\\mu$$ and variance $$\\rho$$</p> <p></p> <p>At each iteration we have our prior knowledge (in blue) and a new measurement (in orange) and we account for both source of information computing an average (in green)</p> <p></p> <p>The final mean gets shifted which is in between the two old means, the mean of the prior, and the mean of the measurement. It\u2019s slightly further on the measurement side because the measurement was more certain as to where the vehicle is than prior. The more certain we are, the more we pull the mean on the direction of the certain answer. source</p> <p>Iteration after iteration the variance decreases (the spread of the blue gaussian), providing a better estimation (in green) despite the noisy measurements (in red) source</p> <p></p> <p>A reference library is available here</p>"},{"location":"supplement3/","title":"Interact with a Mobile Phone via BLE","text":"<p>We aim at fast prototyping and Thunkable is an excellent tool</p> <p></p> <p>The arduino code, adapted from https://www.instructables.com/ESP32-BLE-Android-App-Arduino-IDE-AWESOME/ is the following</p> <pre><code>/*\n    Video: https://www.youtube.com/watch?v=oCMOYS71NIU\n    Based on Neil Kolban example for IDF: https://github.com/nkolban/esp32-snippets/blob/master/cpp_utils/tests/BLE%20Tests/SampleNotify.cpp\n    Ported to Arduino ESP32 by Evandro Copercini\n\n   Create a BLE server that, once we receive a connection, will send periodic notifications.\n   The service advertises itself as: 6E400001-B5A3-F393-E0A9-E50E24DCCA9E\n   Has a characteristic of: 6E400002-B5A3-F393-E0A9-E50E24DCCA9E - used for receiving data with \"WRITE\" \n   Has a characteristic of: 6E400003-B5A3-F393-E0A9-E50E24DCCA9E - used to send data with  \"NOTIFY\"\n\n   The design of creating the BLE server is:\n   1. Create a BLE Server\n   2. Create a BLE Service\n   3. Create a BLE Characteristic on the Service\n   4. Create a BLE Descriptor on the characteristic\n   5. Start the service.\n   6. Start advertising.\n\n   In this example rxValue is the data received (only accessible inside that function).\n   And txValue is the data to be sent, in this example just a byte incremented every second. \n*/\n#include &lt;BLEDevice.h&gt;\n#include &lt;BLEServer.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLE2902.h&gt;\n\n// 78:21:84:9f:24:de\n\nBLECharacteristic *pCharacteristic;\nbool deviceConnected = false;\nfloat txValue = 0;\nconst int readPin = 32; // Use GPIO number. See ESP32 board pinouts\n//const int LED = 9; // Could be different depending on the dev board. I used the DOIT ESP32 dev board.\n\n//std::string rxValue; // Could also make this a global var to access it in loop()\n\n// See the following for generating UUIDs:\n// https://www.uuidgenerator.net/\n\n#define SERVICE_UUID           \"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\" // UART service UUID\n#define CHARACTERISTIC_UUID_RX \"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\" // Qui ricevi da EPS32\n#define CHARACTERISTIC_UUID_TX \"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\" // Qui invii\n\nclass MyServerCallbacks: public BLEServerCallbacks {\n    void onConnect(BLEServer* pServer) {\n      deviceConnected = true;\n    };\n\n    void onDisconnect(BLEServer* pServer) {\n      deviceConnected = false;\n    }\n};\n\n\n\nclass MyCallbacks: public BLECharacteristicCallbacks {\n    void onWrite(BLECharacteristic *pCharacteristic) {\n      std::string rxValue = pCharacteristic-&gt;getValue();\n\n      char letto[] = \"          \";\n\n      if (rxValue.length() &gt; 0) {\n        Serial.println(\"*********\");\n        Serial.print(\"Received Value: \");\n\n        for (int i = 0; i &lt; rxValue.length(); i++) {\n          Serial.print(rxValue[i]);\n          letto[i]=rxValue[i];\n        }\n\n        Serial.println();\n\n        String a = String(letto);\n\n        Serial.print(a.toFloat());\n\n        // Do stuff based on the command received from the app\n        if (rxValue.find(\"A\") != -1) { \n          Serial.print(\"Turning ON!\");\n          digitalWrite(LED, HIGH);\n        }\n        else if (rxValue.find(\"B\") != -1) {\n          Serial.print(\"Turning OFF!\");\n          digitalWrite(LED, LOW);\n        }\n\n        Serial.println();\n        Serial.println(\"*********\");\n      }\n    }\n};\n\nvoid setup() {\n  Serial.begin(115200);\n\n  pinMode(LED, OUTPUT);\n\n  // Create the BLE Device\n  BLEDevice::init(\"ESP32 UART Test\"); // Give it a name\n\n  Serial.print(\"local BLE Address is: \");\n  Serial.println(BLEDevice::getAddress().toString().c_str());\n\n  // Create the BLE Server\n  BLEServer *pServer = BLEDevice::createServer();\n  pServer-&gt;setCallbacks(new MyServerCallbacks());\n\n  // Create the BLE Service\n  BLEService *pService = pServer-&gt;createService(SERVICE_UUID);\n\n\n  // BleCharacteristic deviceHealthCharacteristic(\"deviceHealth\", BleCharacteristicProperty::READ, deviceHealthUuid, serviceUuid);\n  // see https://community.thunkable.com/t/ble-hrm-reading-bpm/2441754/6\n\n\n  // Create a BLE Characteristic\n  pCharacteristic = pService-&gt;createCharacteristic(\n                      CHARACTERISTIC_UUID_TX,\n                      //BLECharacteristic::PROPERTY_NOTIFY\n                      BLECharacteristic::PROPERTY_READ\n                    );\n\n  pCharacteristic-&gt;addDescriptor(new BLE2902());\n\n  BLECharacteristic *pCharacteristic = pService-&gt;createCharacteristic(\n                                         CHARACTERISTIC_UUID_RX,\n                                         BLECharacteristic::PROPERTY_WRITE\n                                       );\n\n  pCharacteristic-&gt;setCallbacks(new MyCallbacks());\n\n  // Start the service\n  pService-&gt;start();\n\n  // Start advertising\n  pServer-&gt;getAdvertising()-&gt;start();\n  Serial.println(\"Waiting a client connection to notify...\");\n}\n\nvoid loop() {\n\n  if (deviceConnected) {\n    // Fabricate some arbitrary junk for now...\n    txValue = analogRead(readPin) / 3.456; // This could be an actual sensor reading!\n\n    // Let's convert the value to a char array:\n    char txString[8]; // make sure this is big enuffz\n    dtostrf(txValue, 1, 2, txString); // float_val, min_width, digits_after_decimal, char_buffer\n\n//    pCharacteristic-&gt;setValue(&amp;txValue, 1); // To send the integer value\n    pCharacteristic-&gt;setValue(\"Hello!\"); // Sending a test message\n    //pCharacteristic-&gt;setValue(txString);\n\n    pCharacteristic-&gt;notify(); // Send the value to the app!\n    Serial.print(\"*** Sent Value: \");\n    Serial.print(txString);\n    Serial.println(\" ***\");\n\n    // You can add the rxValue checks down here instead\n    // if you set \"rxValue\" as a global var at the top!\n    // Note you will have to delete \"std::string\" declaration\n    // of \"rxValue\" in the callback function.\n//    if (rxValue.find(\"A\") != -1) { \n//      Serial.println(\"Turning ON!\");\n//      digitalWrite(LED, HIGH);\n//    }\n//    else if (rxValue.find(\"B\") != -1) {\n//      Serial.println(\"Turning OFF!\");\n//      digitalWrite(LED, LOW);\n//    }\n  }\n\n  delay(1000);\n}\n\n</code></pre> <pre><code>// Adapted from https://github.com/SIMS-IOT-Devices/FreeRTOS-ESP-IDF-BLE-Server\n\n#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"esp_event.h\"\n#include \"nvs_flash.h\"\n#include \"esp_log.h\"\n#include \"esp_nimble_hci.h\"\n#include \"nimble/nimble_port.h\"\n#include \"nimble/nimble_port_freertos.h\"\n#include \"host/ble_hs.h\"\n#include \"services/gap/ble_svc_gap.h\"\n#include \"services/gatt/ble_svc_gatt.h\"\n#include \"sdkconfig.h\"\n\nchar *TAG = \"BLE-Server\";\nuint8_t ble_addr_type;\nvoid ble_app_advertise(void);\n\n//@_____________________Define UUIDs______________________________________\n//!! b2bbc642-46da-11ed-b878-0242ac120002\n//static const ble_uuid128_t gatt_svr_svc_uuid =\n//    BLE_UUID128_INIT(0x02, 0x00, 0x12, 0xac, 0x42, 0x02, 0x78, 0xb8, 0xed, 0x11, 0xda, 0x46, 0x42, 0xc6, 0xbb, 0xb2);\n\nstatic const ble_uuid128_t gatt_svr_svc_uuid =\n    BLE_UUID128_INIT(0x9e, 0xca, 0xdc, 0x24, 0x0e, 0xe5, 0xa9, 0xe0, 0x93, 0xf3, 0xa3, 0xb5, 0x01, 0x00, 0x40, 0x6e);\n\n\n//!! c9af9c76-46de-11ed-b878-0242ac120002\n//static const ble_uuid128_t gatt_svr_chr_uuid =\n//    BLE_UUID128_INIT(0x02, 0x00, 0x12, 0xac, 0x42, 0x02, 0x78, 0xb8, 0xed, 0x11, 0xde, 0x46, 0x76, 0x9c, 0xaf, 0xc9);\n\n// 6E400002-B5A3-F393-E0A9-E50E24DCCA9E    \n\nstatic const ble_uuid128_t gatt_svr_chr_read_uuid =\n    BLE_UUID128_INIT(0x9e, 0xca, 0xdc, 0x24, 0x0e, 0xe5, 0xa9, 0xe0, 0x93, 0xf3, 0xa3, 0xb5, 0x02, 0x00, 0x40, 0x6e);\nstatic const ble_uuid128_t gatt_svr_chr_write_uuid =\n    BLE_UUID128_INIT(0x9e, 0xca, 0xdc, 0x24, 0x0e, 0xe5, 0xa9, 0xe0, 0x93, 0xf3, 0xa3, 0xb5, 0x03, 0x00, 0x40, 0x6e);\n\n\n// Write data to ESP32 defined as server\nstatic int device_write(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)\n{\n    printf(\"Data from the client: %.*s\\n\", ctxt-&gt;om-&gt;om_len, ctxt-&gt;om-&gt;om_data);\n    return 0;\n}\n\n// Read data from ESP32 defined as server\nstatic int device_read(uint16_t con_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)\n{\n    os_mbuf_append(ctxt-&gt;om, \"Data from the server\", strlen(\"Data from the server\"));\n    return 0;\n}\n\nstatic const struct ble_gatt_svc_def gatt_svcs[] = {\n    {.type = BLE_GATT_SVC_TYPE_PRIMARY,\n     .uuid = &amp;gatt_svr_svc_uuid.u,                      // Define UUID for device type\n     .characteristics = (struct ble_gatt_chr_def[]){\n         {.uuid = &amp;gatt_svr_chr_write_uuid.u,           // Define UUID for reading\n          .flags = BLE_GATT_CHR_F_READ,\n          .access_cb = device_read},\n         {.uuid = &amp;gatt_svr_chr_read_uuid.u,           // Define UUID for writing\n          .flags = BLE_GATT_CHR_F_WRITE,\n          .access_cb = device_write},\n         {0}}},\n    {0}};\n\n\n\n// BLE event handling\nstatic int ble_gap_event(struct ble_gap_event *event, void *arg)\n{\n    switch (event-&gt;type)\n    {\n    // Advertise if connected\n    case BLE_GAP_EVENT_CONNECT:\n        ESP_LOGI(\"GAP\", \"BLE GAP EVENT CONNECT %s\", event-&gt;connect.status == 0 ? \"OK!\" : \"FAILED!\");\n        if (event-&gt;connect.status != 0)\n        {\n            ble_app_advertise();\n        }\n        break;\n    // Advertise again after completion of the event\n    case BLE_GAP_EVENT_ADV_COMPLETE:\n        ESP_LOGI(\"GAP\", \"BLE GAP EVENT\");\n        ble_app_advertise();\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\n// Define the BLE connection\nvoid ble_app_advertise(void)\n{\n    // GAP - device name definition\n    struct ble_hs_adv_fields fields;\n    const char *device_name;\n    memset(&amp;fields, 0, sizeof(fields));\n    device_name = ble_svc_gap_device_name(); // Read the BLE device name\n    fields.name = (uint8_t *)device_name;\n    fields.name_len = strlen(device_name);\n    fields.name_is_complete = 1;\n    ble_gap_adv_set_fields(&amp;fields);\n\n    // GAP - device connectivity definition\n    struct ble_gap_adv_params adv_params;\n    memset(&amp;adv_params, 0, sizeof(adv_params));\n    adv_params.conn_mode = BLE_GAP_CONN_MODE_UND; // connectable or non-connectable\n    adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN; // discoverable or non-discoverable\n    ble_gap_adv_start(ble_addr_type, NULL, BLE_HS_FOREVER, &amp;adv_params, ble_gap_event, NULL);\n}\n\n// The application\nvoid ble_app_on_sync(void)\n{\n    ble_hs_id_infer_auto(0, &amp;ble_addr_type); // Determines the best address type automatically\n    ble_app_advertise();                     // Define the BLE connection\n}\n\n// The infinite task\nvoid host_task(void *param)\n{\n    nimble_port_run(); // This function will return only when nimble_port_stop() is executed\n}\n\nvoid app_main()\n{\n    nvs_flash_init();                          // 1 - Initialize NVS flash using\n    //esp_nimble_hci_and_controller_init();      // 2 - Initialize ESP controller\n    nimble_port_init();                        // 3 - Initialize the host stack\n    ble_svc_gap_device_name_set(\"BLE-Server\"); // 4 - Initialize NimBLE configuration - server name\n    ble_svc_gap_init();                        // 4 - Initialize NimBLE configuration - gap service\n    ble_svc_gatt_init();                       // 4 - Initialize NimBLE configuration - gatt service\n    ble_gatts_count_cfg(gatt_svcs);            // 4 - Initialize NimBLE configuration - config gatt services\n    ble_gatts_add_svcs(gatt_svcs);             // 4 - Initialize NimBLE configuration - queues gatt services.\n    ble_hs_cfg.sync_cb = ble_app_on_sync;      // 5 - Initialize application\n    nimble_port_freertos_init(host_task);      // 6 - Run the thread\n}\n</code></pre>"},{"location":"supplement4/","title":"From Wokwi to a real device","text":"<ol> <li>Compile the code and on the code editor press F1 to download the firmware. It is a .bin file, let's name it sketch.bin file </li> <li> <p><code>esptool.py --chip esp32 --port \"/dev/ttyUSB0\" --baud 921600  --before default_reset --after hard_reset write_flash  -z --flash_mode keep --flash_freq keep --flash_size keep 0x1000 \"bootloader.bin\" 0x8000 \"partitions.bin\" 0xe000 \"boot_app0.bin\" 0x10000 \"sketch.bin\"</code> Once partitions and bootloader are uploaded, you can simply upload the sketch. To upload for the first time the partitions and the bootloader you can simply used arduino IDE </p> </li> <li> <p><code>esptool.py --chip esp32 --port \"/dev/ttyUSB0\" --baud 921600  --before default_reset --after hard_reset write_flash  -z --flash_mode keep --flash_freq keep --flash_size keep 0x10000 ./sketch.bin</code></p> </li> </ol> <p>In principle you can even use a Web tool</p>"},{"location":"supplement4/#partition-table","title":"Partition Table","text":"# Name Type SubType Offset Size Flags nvs data nvs 0x9000 0x5000 otadata data ota 0xe000 0x2000 app0 app ota_0 0x10000 0x140000 app1 app ota_1 0x150000 0x140000 spiffs data spiffs 0x290000 0x160000 coredump data coredump 0x3F0000 0x10000"}]}